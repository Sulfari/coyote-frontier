using Content.Client.Guidebook;
using Content.Client.Pinpointer;
using Content.Client.Station;
using Content.Server.Maps;
using Content.Shared._NF.Shipyard.Prototypes;
using Content.Shared.Atmos;
using Content.Shared.Guidebook;
using Content.Shared.Lathe;
using Content.Shared.Pinpointer;
using Content.Shared.Tag;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.EntitySerialization.Systems;
using Robust.Shared.Map.Components;
using Robust.Shared.Physics;
using Robust.Shared.Physics.Components;
using Robust.Shared.Prototypes;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using static Content.Shared.Pinpointer.SharedNavMapSystem;

namespace Content.Client._NF.Shipyard.UI;

[GenerateTypedNameReferences]
public sealed partial class VesselRow : PanelContainer
{
    [Dependency] private readonly IEntitySystemManager _entitySystemManager = default!;
    [Dependency] private readonly EntityManager _entityManager = default!;
    [Dependency] private readonly IPrototypeManager _protoManager = default!;
    private readonly MapLoaderSystem _mapLoader;
    private readonly MapSystem _mapSystem;
    private readonly GuidebookSystem _guidebook = default!;
    public VesselPrototype? Vessel;
    private ShipDetailsPopup _detailWindow;
    ProtoId<TagPrototype>[] WallTags = { "Wall", "Window" };
    private readonly Dictionary<string, (string?, Color?)> ShownProtoIds = new() {
        { "BaseLathe", (null, Color.White) },
        { "BaseLatheLube", (null, Color.White) },
        { "SmallConstructibleMachine", (null, Color.Gray) },
        { "ConstructibleMachine", (null, Color.Gray) },
        { "Thruster", ("shipyard-preview-comp-thruster", Color.Brown) },
        { "ThrusterSecurity", (null, Color.Olive) },
        { "SmallThruster", ("shipyard-preview-comp-mini-thruster", Color.Brown) },
        { "MedicalTechFab", (null, Color.Blue) },
        { "EngineeringTechFab", (null, Color.Yellow) },
        { "ServiceTechFab", (null, Color.GreenYellow) },
        { "MercenaryTechFab", (null, Color.Olive) },
        { "BaseGeneratorShuttle", (null, Color.Yellow) },
        { "PortableGeneratorDKJr", (null, Color.Yellow) },
        { "PortableGeneratorDK", (null, Color.Yellow) },
        { "PortableGeneratorSwitchableBase", (null, Color.Yellow) },
        { "PortableGeneratorBase", (null, Color.Yellow) },
        { "AmeController", (null, Color.Yellow) },
        { "ComputerShuttle", (null, Color.Olive) },
    };


    public VesselRow(VesselPrototype prototype)
    {
        Vessel = prototype;
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        _mapLoader = _entityManager.System<MapLoaderSystem>();
        _mapSystem = _entityManager.System<MapSystem>();
        _guidebook = _entitySystemManager.GetEntitySystem<GuidebookSystem>();
        _detailWindow = new(this);

        Guidebook.OnPressed += LoadVesselDetails;
    }

    public struct VesselDetails
    {
        public bool Valid = false;
        public int TileCount = 0;
        public int ThrusterCount = 0;
        public bool HasMedfab = false;
        public bool HasMercfab = false;

        public EntityUid map;

        public VesselDetails() { }
    }

    public enum ShipyardUiKey
    {
        Key
    }

    public VesselDetails LoadVesselDetails()
    {
        var details = new VesselDetails();

        try
        {
            if (Vessel?.ShuttlePath == null)
                return details;
            var mapUid = _mapSystem.CreateMap(out var mapId);
            var entitySystem = _entitySystemManager.GetEntitySystem<NavMapSystem>();
            var migrationSystem = _entityManager.System<MapMigrationSystem>();
            var stationSys = _entitySystemManager.GetEntitySystem<StationSystem>();

            _entityManager.EnsureComponent<PhysicsComponent>(mapUid);
            _entityManager.EnsureComponent<FixturesComponent>(mapUid);
            if (_mapLoader.TryLoadGrid(mapId, Vessel.ShuttlePath, out var grid))
            {
                if (!grid.HasValue)
                {
                    return details;
                }

                var map = _entityManager.GetComponent<TransformComponent>(grid.Value.Owner).ParentUid;
                var entities = _mapSystem.GetAnchoredEntities(grid.Value.Owner, grid.Value, grid.Value.Comp.LocalAABB);
                var navmap = _entityManager.EnsureComponent<NavMapComponent>(grid.Value.Owner);
                var mapgrid = _entityManager.GetComponent<MapGridComponent>(grid.Value.Owner);

                RefreshGrid(mapUid, navmap!, mapgrid, entities);

                details.map = grid.Value.Owner;

                details.TileCount = _mapSystem.GetAllTiles(grid.Value.Owner, grid).Count();
            }

            details.Valid = true;
            return details;
        }
        catch (Exception e)
        {
            return details;
        }
    }

    public void DeleteGridData(EntityUid mapOwner)
    {
        _entityManager.DeleteEntity(mapOwner);
    }

    private void RefreshGrid(EntityUid uid, NavMapComponent component, MapGridComponent mapGrid, IEnumerable<EntityUid> entities)
    {
        // Clear stale data
        component.Chunks.Clear();
        component.Beacons.Clear();

        // Refresh beacons
        var query = _entityManager.EntityQueryEnumerator<LatheComponent, TransformComponent>();
        foreach (var entity in entities) {
            _entityManager.TryGetComponent<MetaDataComponent>(entity, out var meta);

            string? name = null;
            Color? color = null;
            bool show = false;

            if (meta != null && meta.EntityPrototype != null && meta.EntityPrototype.Parents != null)
            {
                // Try to find parents first
                foreach (var protoId in meta.EntityPrototype.Parents)
                {
                    if (ShownProtoIds.TryGetValue(protoId, out var parentTuple))
                    {
                        name = parentTuple.Item1;
                        color = parentTuple.Item2;
                        show = true;
                        break;
                    }
                }

                // Overwrite with primary ID if more specific category is found
                if (ShownProtoIds.TryGetValue(meta.EntityPrototype.ID, out var tuple))
                {
                    name = tuple.Item1;
                    color = tuple.Item2;
                    show = true;
                }
            }

            if (show)
            {
                var qTransComp = _entityManager.GetComponent<TransformComponent>(entity);

                UpdateNavMapBeaconData(entity, qTransComp, name, color);
            }
        }

        // Loop over all tiles
        var tileRefs = _mapSystem.GetAllTiles(uid, mapGrid);

        foreach (var tileRef in tileRefs)
        {
            var tile = tileRef.GridIndices;
            var chunkOrigin = SharedMapSystem.GetChunkIndices(tile, ChunkSize);

            var chunk = EnsureChunk(component, chunkOrigin);
            RefreshTileEntityContents(uid, component, mapGrid, chunkOrigin, tile, setFloor: true);
        }
    }

    private void UpdateNavMapBeaconData(EntityUid uid, TransformComponent? xform = null, string? customName = null, Color? color = default)
    {
        if (!_entityManager.TransformQuery.Resolve(uid, ref xform))
            return;

        if (xform.GridUid == null)
            return;

        if (!_entityManager.GetEntityQuery<NavMapComponent>().TryComp(xform.GridUid, out var navMap))
            return;

        var meta = _entityManager.MetaQuery.GetComponent(uid);
        var changed = navMap.Beacons.Remove(meta.NetEntity);

        if (TryCreateNavMapBeaconData(uid, xform, meta, out var beaconData, customName, color))
        {
            navMap.Beacons.Add(meta.NetEntity, beaconData.Value);
            changed = true;
        }
    }

    protected bool TryCreateNavMapBeaconData(EntityUid uid, TransformComponent xform, MetaDataComponent meta, [NotNullWhen(true)] out NavMapBeacon? beaconData, string? customName = null, Color? color = null)
    {
        beaconData = null;

        if (xform.GridUid == null || !xform.Anchored)
            return false;

        var name = meta.EntityName;
        if (string.IsNullOrEmpty(name))
            name = meta.EntityName;

        beaconData = new NavMapBeacon(meta.NetEntity, color ?? Color.White, Loc.GetString(customName ?? name), xform.LocalPosition);

        return true;
    }

    private NavMapChunk EnsureChunk(NavMapComponent component, Vector2i origin)
    {
        if (!component.Chunks.TryGetValue(origin, out var chunk))
        {
            chunk = new(origin);
            component.Chunks[origin] = chunk;
        }

        return chunk;
    }

    private (int NewVal, NavMapChunk Chunk) RefreshTileEntityContents(EntityUid uid,
        NavMapComponent component,
        MapGridComponent mapGrid,
        Vector2i chunkOrigin,
        Vector2i tile,
        bool setFloor)
    {
        var relative = SharedMapSystem.GetChunkRelative(tile, ChunkSize);
        var chunk = EnsureChunk(component, chunkOrigin);
        ref var tileData = ref chunk.TileData[GetTileIndex(relative)];

        // Clear all data except for floor bits
        if (setFloor)
            tileData = FloorMask;
        else
            tileData &= FloorMask;

        var enumerator = _mapSystem.GetAnchoredEntitiesEnumerator(uid, mapGrid, tile);
        while (enumerator.MoveNext(out var ent))
        {
            var category = GetEntityType(ent.Value);
            if (category == NavMapChunkType.Invalid)
                continue;

            tileData |= (int)AtmosDirection.All << (int)category;
        }
        // Remove walls that intersect with doors (unless they can both physically fit on the same tile)
        // TODO NAVMAP why can this even happen?
        // Is this for blast-doors or something?

        // Shift airlock bits over to the wall bits
        var shiftedAirlockBits = (tileData & AirlockMask) >> ((int)NavMapChunkType.Airlock - (int)NavMapChunkType.Wall);

        // And then mask door bits
        tileData &= ~shiftedAirlockBits;

        return (tileData, chunk);
    }

    public NavMapChunkType GetEntityType(EntityUid uid)
    {
        var _doorQuery = _entityManager.GetEntityQuery<NavMapDoorComponent>();
        if (_doorQuery.HasComp(uid))
            return NavMapChunkType.Airlock;
        var eq = _entityManager.GetEntityQuery<TagComponent>();
        eq.TryComp(uid, out var comp);
        foreach (var tag in WallTags)
        {
            if (comp?.Tags?.Contains(tag) ?? false)
                return NavMapChunkType.Wall;
        }

        return NavMapChunkType.Invalid;
    }

    private void LoadVesselDetails(BaseButton.ButtonEventArgs args)
    {
        _detailWindow.LoadAndShowDetails();
    }

    public void LoadVesselGuidebook()
    {
        if (Vessel?.GuidebookPage == null)
            return;

        List<ProtoId<GuideEntryPrototype>> guidebookEntries = new() { Vessel.GuidebookPage.Value };
        _guidebook.OpenHelp(guidebookEntries);

    }
}
